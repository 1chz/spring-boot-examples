# 작업 이벤트 큐

## 실행

---

프로젝트를 클론하고 데이터베이스를 설정한다.

기본적으로 H2 인메모리로 설정돼있다.

서버모드를 사용하겠다면 본인이 사용하고있는 머신에 H2 서버모드 설정을 하고 하기의 주석을 변경하라.

<br />

```yaml
#application.yaml
spring:
  datasource:
    url: jdbc:h2:mem:testdb
#   url: jdbc:h2:tcp://localhost/~/test
    username: sa
    password:
```

<br />

이후 프로젝트를 실행하고 웹 브라우저를 열어 주소창에 `localhost:8080/transactions`를 입력하라.

기본적으로 위 주소로 접근시 50번의 거래가 발생하도록 설정돼있다.

만약 단건 요청을 하고 싶다면 주소창에 `localhost:8080/transaction`을 입력하면 된다

서버로 요청을 보낸 후 콘솔창의 로그를 확인하면 다음과 유사한 모습을 볼 수 있을 것이다.

<br />

![image](https://user-images.githubusercontent.com/71188307/147766441-fd98b4ee-a691-41dd-8470-4fe66b276076.png)

<br />

## 유스케이스

---

다음과 같은 `유스케이스`가 있다고 가정하자

<br />

1. 사용자가 결제를 요청
2. 컨트롤러가 요청을 받음
3. 사용자의 요청에 대한 유효성 검증
4. `STANDBY` 상태의 유효한 거래 생성
5. 거래를 데이터베이스에 저장
6. 이벤트 퍼블리셔가 거래 이벤트를 퍼블리싱
7. 사용자에게 거래 요청에 대한 응답을 보내고 HTTP 통신을 종료
8. 발생된 거래 이벤트를 이벤트 리스너가 감지하고 거래 이벤트에서 거래정보를 추출
9. 작업 큐가 꽉 차있지 않다면 거래 정보를 작업 큐에 입력하고 거래의 상태를 `QUEUE`로 데이터베이스 업데이트
10. 작업큐가 꽉 차있다면 상태를 `QUEUE_WAIT`으로 데이터베이스 업데이트
11. 백그라운드 스레드에서 작업큐에 있는 거래들을 처리하고 상태를 `SUCCESS` 혹은 `FAILURE`로 업데이트
12. 거래 완료에 대한 정보를 사용자의 앱으로 푸쉬

<br />

## 설명

---

이렇게 비동기로 처리하지 않는다고 가정하면, 거래 처리시간이 길어질때 사용자는 거래가 끝날때까지 거래화면을 쳐다보고 있어야만 한다.

따라서 요청을 받자마자 응답하여 사용자와의 커넥션을 빠르게 끊고, 이후 백그라운드에서 처리를 한 후 사용자에게 응답을 주면 사용자 경험이 더 좋아질 것이다.

이 저장소의 코드는 위의 구조를 구축하기 위한 방법이다.

<br />
